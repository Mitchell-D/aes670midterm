"""
Generates custom RGBs based on user-selected values and prompts the user to
choose classification samples using the RGBs.

band  range          reason
3     459-479nm      blue
4     545-565nm      green
1     620-670nm      near-red
16    862-877nm      NIR / aerosol distinction
19    916-965nm      H2O absorption
5     1230-1250nm    optical depth
26    1360-1390nm    cirrus band
6     1628-1652nm    snow/ice band
7     2106-2155nm    cloud particle size
20    3660-3840nm    SWIR
21    3929-3989      another SWIR
27    6535-6895nm    Upper H2O absorption
28    7175-7475nm    Lower H2O absorption
29    8400-8700nm    Infrared cloud phase, emissivity diff 11-8.5um
31    10780-11280nm  clean LWIR
32    11770-12270nm  less clean LWIR
33    14085-14385nm  dirty LWIR
"""

from pathlib import Path
from datetime import datetime as dt
from datetime import timedelta as td
from pprint import pprint as ppt
import numpy as np
import pickle as pkl
import json
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from matplotlib.transforms import Affine2D

from aes670hw2 import laads, modis, geo_helpers, guitools, recipe_book
from aes670hw2 import guitools as gt
from aes670hw2 import geo_plot as gp
from aes670hw2 import enhance as enh
from aes670hw2 import PixelCat
from aes670hw2 import classify

""" Set up environment """
target_time = dt(year=2022, month=9, day=5, hour=8, minute=35)
l1b_pkl = Path("data/midterm_l1b.pkl")
fig_dir = Path("./figures")
data_dir = Path("./data")
debug=True

""" Load the pkl generated by get_region_pkl.py """
data, info, geo, sunsat = pkl.load(l1b_pkl.open("rb"))
# Convert band number to band array index
b2idx = lambda b: [ info[i]["band"] for i in range(len(info)) ].index(b)
lat, lon, _ = geo
sza, _, vza, _ = sunsat
all_bands = [info[i]["band"] for i in range(len(info))]

print(sza[100,500])
print(vza[100,500])
exit(0)

# Optionally scale back to raw reflectance rather than BRDF
#data = [np.cos(np.deg2rad(sunsat[0]))*data[i]
#        if info[i]["is_reflective"] else data[i]
#        for i in range(len(data)) ]

'''
""" Generate a greyscale of every band """
for i in range(len(data)):
    gp.generate_raw_image(
            enh.linear_gamma_stretch(data[i]),
            fig_dir.joinpath(f"gray/gray_band_{info[i]['band']}.png"))
'''

""" Make a few RGBs """
hnorm = lambda X: enh.norm_to_uint(enh.histogram_equalize(X,256)[0],
                                   256,np.uint8)
gnorm = lambda X,g:enh.norm_to_uint(enh.linear_gamma_stretch(X, gamma=g),
                                    256,np.uint8)

""" Define PixelCat objects for dcp, dust, and custom RGB recipes """
fire_bands = ["dIR", "LWIR", "VIS"]
fire_data = [enh.linear_gamma_stretch(X)
             for X in [data[b2idx(21)]-data[b2idx(31)],
                       data[b2idx(31)],
                       data[b2idx(1)]]]
fire_data[1] = 1-fire_data[1]
fire_cat = PixelCat(arrays=fire_data, bands=fire_bands)

tc_bands = ["RED", "GREEN", "BLUE"]
tc_data = [ np.clip(hnorm(data[b2idx(b)])/255,0,1) for b in (1, 4, 3) ]
tc_cat = PixelCat(arrays=tc_data, bands=tc_bands)

dcp_bands = ["CIRRUS", "RED", "PHASE"]
dcp_data = [ enh.linear_gamma_stretch(data[b2idx(b)]) for b in (26,1,6) ]
dcp_cat = PixelCat( arrays=dcp_data, bands=dcp_bands)

dust_bands = ["THICK", "PHASE", "TEMP"]
dust_data = [enh.linear_gamma_stretch(X)
             for X in [data[b2idx(32)]-data[b2idx(31)],
                       data[b2idx(31)]-data[b2idx(29)],
                       data[b2idx(31)]]]
dust_cat = PixelCat(arrays=dust_data, bands=dust_bands)

custom_bands = ["LWIR", "NDVI", "dIR"]
NDVI = (data[b2idx(16)]-data[b2idx(1)]) / (data[b2idx(16)]+data[b2idx(1)])
custom_cat = PixelCat(
        arrays=[enh.linear_gamma_stretch(data[b2idx(31)]),
                enh.linear_gamma_stretch(NDVI),
                1-enh.linear_gamma_stretch(data[b2idx(29)], gamma=.3)],
        bands=custom_bands)

'''
""" Ask the user to choose enhancement parameters for RGBs """
# Prompt the user to choose truecolor RGB gamma
for b in fire_bands:
    fire_g = fire_cat.pick_gamma(b, set_band=True, gamma_scale=5)
    print(f'("{b}", {fire_g:.4f})')
fire_rgb = fire_cat.get_rgb(fire_bands)

# Prompt the user to choose custom RGB gamma
for b in custom_bands:
    custom_g = custom_cat.pick_gamma(b, set_band=True)
    print(f'("{b}", {custom_g:.4f})')

# Prompt the user to choose dust RGB gamma
# Black is high thin ice clouds, red is optically-thick cold clouds because
# reflectance in the SWIR band
# Prompt the user to choose truecolor RGB gamma
for b in tc_bands:
    tc_g = tc_cat.pick_gamma(b, set_band=True, gamma_scale=4)
    print(f'("{b}", {tc_g:.4f})')
tc_rgb = tc_cat.get_rgb(tc_bands)

# Prompt the user to choose DCP RGB gamma
for b in dcp_bands:
    dcp_g = dcp_cat.pick_gamma(b, gamma_scale=3, set_band=True)
    print(f'("{b}", {dcp_g:.4f})')
dcp_rgb = dcp_cat.get_rgb(dcp_bands)

'''

for b in dust_bands:
    dust_g = dust_cat.pick_gamma(b, set_band=True, gamma_scale=2)
    print(f'("{b}", {dust_g:.4f})')
dust_rgb = dust_cat.get_rgb(dust_bands)

""" Use prior selection of gamma parameters to fetch enhanced RGBs """
prev_selections = [
        (fire_cat, [("dIR", 1.0980), ("LWIR", 0.6275), ("VIS", 1.2549)]),
        (tc_cat, [("RED", 1.4588), ("GREEN", 2.0824), ("BLUE", 1.8706)]),
        (dcp_cat, [("CIRRUS", 2.0078), ("RED", 1.3882), ("PHASE", 0.5725)]),
        #(dust_cat, [("THICK", 0.4863), ("PHASE", 0.2471), ("TEMP", 0.1333)]),
        (custom_cat, [("LWIR", 0.2706), ("NDVI", 0.2000), ("dIR", 0.5686)]),
        ]
for cat, selection in prev_selections:
    for b,g in selection:
        cat.set_band(enh.gamma(cat.band(b),g),band=b,replace=True)

fire_rgb = fire_cat.get_rgb(fire_bands)
tc_rgb = tc_cat.get_rgb(tc_bands)
dcp_rgb = dcp_cat.get_rgb(dcp_bands)
dust_rgb = dust_cat.get_rgb(dust_bands)
custom_rgb = custom_cat.get_rgb(custom_bands)

""" Generate the current selection suite of RGBs """
'''
gp.generate_raw_image(fire_rgb, fig_dir.joinpath("rgbs/rgb_fire.png"))
gp.generate_raw_image(tc_rgb, fig_dir.joinpath("rgbs/rgb_tc.png"))
gp.generate_raw_image(dcp_rgb, fig_dir.joinpath(f"rgbs/rgb_dcp.png"))
gp.generate_raw_image(dust_rgb, fig_dir.joinpath(f"rgbs/rgb_dust.png"))
gp.generate_raw_image(custom_rgb, fig_dir.joinpath(f"rgbs/rgb_custom.png"))
'''

'''
""" Choosing pixel candidates """
classes = []
classes += gt.get_category_series(X=tc_rgb, cat_count=1,
        category_names=["water"])
classes += gt.get_category_series(X=dcp_rgb, cat_count=3,
        category_names=["cirrus", "low cloud", "deep cloud"])
for i in range(len(classes)):
    classes[i]["pixels"] = list(classes[i]["pixels"])
classes += gt.get_category_series(X=custom_rgb, cat_count=2,
        category_names=["rainforest", "savanna"])
classes += gt.get_category_series(X=fire_rgb, cat_count=1,
        category_names=["fire"])
for i in range(len(classes)):
    classes[i]["pixels"] = list(classes[i]["pixels"])
print(json.dumps(classes))
json.dump(classes, data_dir.joinpath("scene_classes.json").open("w"))
'''

""" re-load pixel classes """
class_cmap = {
        "water":np.array([0,0,255]),
        "cirrus":np.array([128,255,255]),
        "deep cloud":255-np.array([255,255,255]),
        "low cloud":np.array([180,0,180]),
        "fire":np.array([255,0,0]),
        "rainforest":np.array([0,128,0]),
        "savanna":np.array([128,128,0]),
        "general cloud":np.array([220,220,220]),
        }
# Bands used in RGBs informing pixel selection are used for classification
sel_bands = (3, 4, 1, 16, 26, 6, 21, 29, 31, 32, 33)
sel_wls = [info[b2idx(b)]["ctr_wl"] for b in sel_bands]
json_path = data_dir.joinpath("scene_classes_squares.json")
json_classes = json.load(json_path.open("r"))
classes = {C["name"]:list(map(np.array, zip(*C["pixels"])))
           for C in json_classes}
class_px = {json_classes[i]["name"]:list(map(list,json_classes[i]["pixels"]))
           for i in range(len(json_classes))}

#'''
"""
Generate truecolor and falsecolor overlay showing pixel sample locations
"""
cbar = []
cbar_res = 128
sample_tc_rgb = (np.clip(np.copy(tc_rgb)**(2),0,1)*255).astype(np.uint8)
#sample_fc_rgb = (np.clip(np.copy(dcp_rgb)**(2),0,1)*255).astype(np.uint8)
sample_fc_rgb = (np.clip(np.copy(dust_rgb)**(2),0,1)*255).astype(np.uint8)
for c in classes.keys():
    class_color = class_cmap[c]
    tmp_cb = np.zeros((cbar_res, cbar_res, 3), dtype=np.uint8)
    tmp_cb[:,:] = class_color
    cbar.append(tmp_cb)
    for y,x in class_px[c]:
        sample_tc_rgb[y,x] = class_color
        sample_fc_rgb[y,x] = class_color
cbar = np.concatenate(cbar, axis=1)
#gp.generate_raw_image(sample_tc_rgb, fig_dir.joinpath(f"rgbs/rgb_tc_samples.png"))
gp.generate_raw_image(sample_fc_rgb, fig_dir.joinpath(f"rgbs/rgb_fc_samples.png"))
#gp.generate_raw_image(cbar, fig_dir.joinpath(f"rgbs/rgb_sample_cbar.png"))
#'''

def get_latex_table(cat_samples:dict):
    cstrings = []
    for cat,samples in cat_samples.items():
        counts = len(samples)
        pixels = np.asarray(samples)
        means = np.average(samples, axis=0)
        stdevs = np.std(samples, axis=0)
        cstr = f"{cat} & {counts} "
        for i in range(means.size):
            cstr += f" & {means[i]:.3f} & {stdevs[i]:.3f} "
        cstr += "\\\\"
        cstrings.append(cstr)
    return "\n".join(cstrings)
bands_r = [ b for b in sel_bands if info[b2idx(b)]['is_reflective'] ]
bands_t = list(filter(lambda b: b not in bands_r, sel_bands))
ckeys = list(classes.keys()) # class keys
sel_data = np.copy(np.dstack(data)) # selected data
# Reflectance wavelengths
wls_r = [ f"{info[b2idx(b)]['ctr_wl']:.3f} $\mu m$" for b in bands_r]
# Thermal wavelengths
wls_t = [ f"{info[b2idx(b)]['ctr_wl']:.3f} $\mu m$" for b in bands_t]

'''
""" Get LaTeX-formatted table of reflectance and thermal class values """
px_r = [np.array([[px[b2idx(b)] for b in bands_r]
                      for px in sel_data[*classes[c]]])
            for c in ckeys]
print(f"class & count & "+" & ".join(wls_r)+" \\\\")
print(get_latex_table({ckeys[i]:px_r[i] for i in range(len(ckeys))}))
# Get a LaTeX-formatted table of thermal class values
px_t = [np.array([[px[b2idx(b)] for b in bands_t]
                      for px in sel_data[*classes[c]]])
            for c in ckeys]
print(f"class & count & "+" & ".join(wls_t)+" \\\\")
print(get_latex_table({ckeys[i]:px_t[i] for i in range(len(ckeys))}))
'''

'''
""" Plot the spectral response of reflectance samples with error bars """
space_r = .2
fig_r, ax_r = plt.subplots()
transform_r = [Affine2D().translate(n, 0.)+ax_r.transData  for n in
           np.linspace(-.5*space_r, .5*space_r, num=len(classes.keys()))]
idx_r = np.array([ b2idx(b) for b in bands_r ])
for i in range(len(ckeys)):
    # Get an array of pixels for this class (group)
    wl_px = [
        np.array([px[b2idx(bands_r[j])]
                  for px in  sel_data[*classes[ckeys[i]]]])
        for j in range(len(bands_r))]
    means = list(map(np.average, np.clip(wl_px, 0, 1)))
    stdevs = list(map(np.std, np.clip(wl_px, 0, 1)))
    ax_r.set_yscale("logit")
    ax_r.set_ylim([0,.8])
    ax_r.errorbar(wls_r, means, yerr=stdevs, marker="o", label=ckeys[i],
                  linestyle=":", transform=transform_r[i], linewidth=1.5,
                  color=tuple(class_cmap[ckeys[i]]/255))
    ax_r.fill_between(
            **{"x":wls_r,
               "y1":[ m-s/3 for m,s in zip(means, stdevs) ],
               "y2":[ m+s/3 for m,s in zip(means, stdevs) ]},
            alpha=.2, transform=transform_r[i],
            color=tuple(class_cmap[ckeys[i]]/255))
    ax_r.grid(visible=True, axis="y")
    ax_r.set_xlabel(f"Wavelength (MODIS bands {', '.join(map(str,bands_r))})",
                    fontsize=12)
    ax_r.set_ylabel(f"Bidirectional Reflectance Factor ($\\rho$), logistic",
                    fontsize=12)
    ax_r.set_title(f"Spectral distribution of reflectance class samples",
                   fontsize=18)
    ax_r.legend(fontsize=12)

fig_r.tight_layout()
fig_r.set_size_inches(18,10)
fig_r.savefig(fig_dir.joinpath("class_dist_ref_square.png").as_posix())
'''

'''
""" Plot the spectral response of thermal samples with error bars """
space_t = .2
fig_t, ax_t = plt.subplots()
transform_t = [Affine2D().translate(n, 0.)+ax_t.transData  for n in
           np.linspace(-.5*space_t, .5*space_t, num=len(classes.keys()))]
idx_t = np.array([ b2idx(b) for b in bands_t ])
for i in range(len(ckeys)):
    # Get an array of pixels for this class (group)
    wl_px = [
        np.array([px[b2idx(bands_t[j])]
                  for px in  sel_data[*classes[ckeys[i]]]])
        for j in range(len(bands_t))]
    means = list(map(np.average, wl_px))
    stdevs = list(map(np.std, wl_px))
    ax_t.errorbar(wls_t, means, yerr=stdevs, marker="o", label=ckeys[i],
                  linestyle=":", transform=transform_t[i], linewidth=1.5,
                  color=tuple(class_cmap[ckeys[i]]/255))
    ax_t.fill_between(
            **{ "x":wls_t,
               "y1":[ m-s/3 for m,s in zip(means, stdevs) ],
               "y2":[ m+s/3 for m,s in zip(means, stdevs) ]},
            alpha=.2, transform=transform_t[i],
            color=tuple(class_cmap[ckeys[i]]/255))
    ax_t.legend()
    ax_t.grid(visible=True, axis="y")
    #ax_t.set_yscale("logit")
    #ax_t.set_ylim([0,.8])
    ax_t.set_xlabel(f"Wavelength (MODIS bands {', '.join(map(str,bands_r))})",
                    fontsize=12)
    ax_t.set_ylabel(f"Brightness Temp ($K$)", fontsize=12)
    ax_t.set_title(f"Spectral distribution of thermal class samples",
                   fontsize=18)
    ax_t.legend(fontsize=12)

fig_t.tight_layout()
fig_t.set_size_inches(18,10)
fig_t.savefig(fig_dir.joinpath("class_dist_temp_square.png").as_posix())
'''

def plot_classes(class_array:np.ndarray, fig_path:Path, class_labels:list,
                 color_map:dict):
    """
    Plots an integer array mapping pixels to a list of class labels
    """
    colors = [ color_map[l]/255 for l in class_labels ]
    cmap, norm = matplotlib.colors.from_levels_and_colors(
            list(range(len(colors)+1)), colors)
    im = plt.imshow(class_array, cmap=cmap, norm=norm, interpolation="none")
    handles = [ Patch(label=class_labels[i], color=colors[i])
               for i in range(len(class_labels)) ]
    plt.legend(handles=handles)
    print(f"saving figure as {fig_path.as_posix()}")
    plt.tick_params(axis="both", which="both", labelbottom=False,
                    labelleft=False, bottom=False, left=False)
    fig = plt.gcf()
    fig.set_size_inches(16,9)
    plt.savefig(fig_path, bbox_inches="tight", dpi=100)
    return

'''
""" Do maximum-likelihood classification """
del class_px["fire"]
mlc, labels = classify.mlc(
        np.dstack([data[b2idx(b)] for b in sel_bands]), class_px)
plot_classes(mlc, fig_dir.joinpath("mlc_full.png"), labels, class_cmap)
ref_mlc, labels = classify.mlc(
        np.dstack([data[b2idx(b)] for b in bands_r]), class_px)
plot_classes(ref_mlc, fig_dir.joinpath("mlc_ref.png"), labels, class_cmap)
therm_mlc, labels = classify.mlc(
        np.dstack([data[b2idx(b)] for b in bands_t]), class_px)
plot_classes(therm_mlc, fig_dir.joinpath("mlc_therm.png"), labels, class_cmap)
'''


""" Get a S&K cloud cover mask """
sk1 = data[b2idx(32)] < 289
sk2 = data[b2idx(1)] > .275 # Region's min SZA is 22.23 degrees
sk3 = np.abs((data[b2idx(16)]/data[b2idx(1)])-1) < .3
sk4 = data[b2idx(26)] > .02

"""
Ask the user to choose an aggressive reflectance upper bound for admitting
a clear pixel. Since we only care about vegetation this is fine since
vegetation has low reflectance overall. The reflectance metric is just the
magnitude of the pixel vector in RGB space.
"""
def ubound(X,v):
    thresh = v/255
    X[np.where(X>thresh)] = 0
    return enh.norm_to_uint(X, 256, np.uint8)
total_ref = np.sqrt(np.sum(np.copy(tc_rgb)**2, axis=2))
ref_ubound = gt.trackbar_select(X=total_ref, func=ubound)/255
ref_mask = total_ref > ref_ubound
cloud_test = np.dstack((sk1,sk2,sk3,sk4, ref_mask))
cloud_mask = np.any(cloud_test, axis=2)

""" Get the user to pick a lower-bound threshold for vegetation using NDVI """
def vfunc(X,v):
    thresh = v/255
    X[np.where(X<thresh)] = 0
    return enh.norm_to_uint(X, 256, np.uint8)
veg_lbound = gt.trackbar_select(X=NDVI, func=vfunc)/255
noveg_mask = NDVI<veg_lbound

'''
According to Fig 3.5 in the textbook, vegetation reflectance is fairly
linear on the NIR range 866-1629nm, which spans a water absorption line
at 916-965nm. Then with two window channels at wavelengths w_1 and w_2
that have reflectances R_1 and R_2, the surface spectral response curve
between the two wavelengths is a linear combination 0 = (R_1-R2)+g*(w_2-w_1).
We want to find a gain that minimizes f(g) = (R1-R2) + g*(w_2-w_1) over the
vegetation surface in order to estimate the clear-sky reflectance at the
absorption wavelength.
'''
dwind_wl = info[b2idx(5)]["ctr_wl"] - info[b2idx(16)]["ctr_wl"] # wl range
dabs_wl =  info[b2idx(19)]["ctr_wl"] - info[b2idx(16)]["ctr_wl"] # abs wl
scale = 3

"""
Define a function that maximizes at a gain value that best aligns 2 window
channels for a surface type that has a linear spectral response between the
channels' center wavelengths
"""
def gain_func(X,v):
    """
    Get the user to find a coefficient that maximizes a function describing
    the alignment of the spectral response of vegetation in 2 window channels
    """
    target = np.abs((X[:,:,1]-X[:,:,0])+scale*((v-127)/255)*dwind_wl)
    target_enh = np.clip(target,0,1)**(1/2)
    target_enh[np.where(noveg_mask)] = 1
    target_enh[np.where(cloud_mask)] = 1
    return 255-enh.norm_to_uint(target_enh, 256, np.uint8)

""" Get the user to select a gain function """
windows = np.dstack((data[b2idx(16)], data[b2idx(5)]))
gain = (scale/255)*(gt.trackbar_select(X=windows, func=gain_func)-127)
print(f"Gain: {gain}")
R_ideal = gain*dabs_wl+windows[:,:,0]
trans = np.clip(data[b2idx(19)]/R_ideal, 0, 1)

""" Find the unmasked pixel with maximum transmittence given the gain """
trans[np.where(noveg_mask)] = 0
trans[np.where(cloud_mask)] = 0
max_y, max_x = map(lambda v: v[0], np.where(trans == np.amax(trans)))
print(f"Found highest-transmission vegetated surface at ({max_y}, {max_x})")

""" Generate an RGB showing where the clear pixel is """
mark_rgb = gt.label_at_index(np.copy(tc_rgb), (max_y, max_x),
                             color=(255,0,0), size=16, thickness=2)
mark_rgb = np.clip(mark_rgb, 0, 1)
gt.quick_render(mark_rgb)
""" gp.generate_raw_image(mark_rgb, fig_dir.joinpath("trans_marker.png")) """

reflective = [
        (b, f"{info[b2idx(b)]['ctr_wl']:.3f}", data[b2idx(b)][max_y,max_x])
        for b in all_bands if info[b2idx(b)]['is_reflective']]
temperature = [
        (b, f"{info[b2idx(b)]['ctr_wl']:.3f}", data[b2idx(b)][max_y,max_x])
        for b in all_bands if not info[b2idx(b)]['is_reflective']]
ref_bands, ref_wl, ref = zip(*reflective)
temp_bands, temp_wl, temp = zip(*temperature)

print("\nClear pixel reflectances:")
print("Wavelength:  ", " & ".join(ref_wl))
print("Reflectance: ", " & ".join([f"{r:.3f}" for r in ref]))
print("\nClear pixel brightness temps:")
print("Wavelength:  ", " & ".join(temp_wl))
print("Temperature: ", " & ".join([f"{t:.3f}" for t in temp]))

'''
gp.basic_plot(
        ref_wl, ref, fig_dir.joinpath("trans_ref.png"), scatter=False,
        plot_spec={
            "title":"TOA Reflectance of highest-transmittence vegetated pixel",
            "xlabel":f"MODIS bands {', '.join(map(str,temp_bands))}",
            "ylabel":f"TOA reflectance factor",
            "grid":True,
            },
        show=True)
gp.basic_plot(
        temp_wl, temp, fig_dir.joinpath("trans_temp.png"), scatter=False,
        plot_spec={
            "title":"TOA brightness temp of highest-transmittence vegetated pixel",
            "xlabel":f"MODIS bands {', '.join(map(str,temp_bands))}",
            "ylabel":f"TOA brightness temperature",
            "grid":True,
            },
        show=True)
'''
